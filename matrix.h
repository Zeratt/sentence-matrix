struct matrix{
    matrix *down; ///указатель на нижний элемент
    matrix *next; ///указатель на правый элемент

    sentence *sc; /// указатель на первый элемент предложения
};

matrix* matrixCreate(matrix *mx) ///может принимать любой пустой указатель
{ ///возвращает указатель на только что созданную и проинициализированную матрицу
    mx = (matrix*)malloc(sizeof(matrix)); ///выделяем память для первого эдемента
    if(mx == NULL)
    {
        printf("Ошибка! Недостаточно памяти для работы программы.");
        exit(1);
    }
    mx->down = NULL;
    mx->next = NULL;
    mx->sc = NULL;
    ///инициализируются начальные значения
    printf("Переходин в подуровень для раобты с новыми данными\n");
    mx->sc = sentenceStart(mx->sc, mx->sc); ///переходим в подструктуру для заполнения данного элемента матрицы

    return mx; ///возвращаем указатель на созданный элемент
}

matrix * matrixDeleteALL(matrix * first) ///передается указатель на первый элемент матрицы
{ ///полностью освобождает память матрицы
    matrix *now = first; ///создаем внутренний рабочий указатель
    matrix *tmp; ///создаем буферную переменную для освобождения памяти

    if(first == NULL) ///стандартная проверка для исключения возможности обращения по памяти не принадлежащей программе
        return NULL;
    for(; first->down != NULL;)
    {
        now = first;
        first = first->down; ///можно так написать т.к. локальный указатель first не меняет внешний
        for(; now->next != NULL;)
        {
            tmp = now; ///запоминаем память, которую собираемся освободить
            now = now->next; ///передвигаем рабочий указатель вперед
            tmp->sc = sentenceDeleteALL(tmp->sc); ///сначала освобождаем память Данного элемента матрицы
            free(tmp); /// а затем саму ячейку
        } ///поскольку цикл не обрабатывает последний элемент строки матрицы, то обработать его нужно отдельно
        now->sc = sentenceDeleteALL(now->sc);
        free(now);
    } ///поскольку цикл не обрабатывает последнюю строку матрицы, то ее нужно обработать отдельно
    now = first;
    for(; now->next != NULL;)
    {
        tmp = now;
        now = now->next;
        tmp->sc=sentenceDeleteALL(tmp->sc);
        free(tmp);
    }
    now->sc = sentenceDeleteALL(now->sc);
    free(now);
    first = NULL;

    return first; ///возвращаем указатель NULL в знак того, что f() добилась того, что было нужно
}

matrix * matrixGoTo(matrix *first, int n, int m) ///передается указатель на первый элемент матрицы и индексы элемента (строка, столбец)
{ ///врзвращает рабочий указатель назодящийся на элемента с индексами n и m
    matrix *now = first; ///внутренний рабочий указатель
    int i, j; ///счетчики для цикла
                                                ///стандартной проверки на first == NULL нету т.к. эта функция вызывается только внутри функций, которые имеют эту проверку
    for(i = 0; i < n && now->down != NULL; i++) ///двигаемся по строкам матрицы, пока не достигнем нужного элемента или не дойдем до конца
        now = now->down;
    for(j = 0; j < m && now->next != NULL; j++) ///двигаемся по столбцам матрицы, пока не достикнем нужного элемента или не дойдем до конца
        now = now->next;
    if((now->next == NULL && j < m) || (now->down == NULL && i < n))
    { ///проверяем не вышли ли мы запределы матрицы во время посика элемента
        printf("Элемент за границами Матрицы\n");
        return NULL;
    }

    return now; ///если все хорошо, то возвращаем указатель на найденный элемент
}


bool matrixIsEmpty(matrix *mx) ///передается указатель на первый эемент матрицы
{ ///возвращает 1 если она пустая или 0 если в ней что-то есть
    if(mx == NULL)
        return 1;
    else
        return 0;
}

int matrixRowCount(matrix *first) ///передается указатель на первый элемент матрицы
{ ///возвращает кол-во строк в матрице
    int c; ///счетчик
    matrix *now = first; ///рабочий указатель

    if(first == NULL) ///стандартная проверка
        return 0;
    for(c = 0; now->down != NULL; c++) ///двигаемся по матрице пока не дойдем до конца
        now = now->down;

    return c+1; ///+1 т.к. мы нашли кол-во строк начиная с нулевой
}

int matrixColCount(matrix *first) ///передается указатель на первый лемент матрицы
{ ///возвращает кол-во столбцов в матрице
    int c; ///счетчик
    matrix *now = first;/// локальный рабочий указатель

    if(first == NULL) ///стандартная проверка
        return 0;
    for(c = 0; now->next != NULL; c++)///двигаемся пока не дойдем до последнего элемента
        now = now->next;

    return c+1; /// +1 т.к. мы нашли кол-во столбцов начиная с нулевого
}

void matrixShowSentenceNM(matrix *first, int n, int m) ///передается указатель на первый элемент матрицы и индексы элемента значение которого выводится
{ ///выводит в консоль значение Данного матрицы с индексами n и m
    matrix *now = first; ///локальный рабочий указатель
    int i, j; ///счетчики циклов

    if(now == NULL) ///стандартная проверка
        return;
    for( i = 0; i < n && now->down != NULL; i++) ///двигаемся пока не дойдем до конца или пока не дойдем до нужной строки
        now = now->down;
    for( j = 0; j < m && now->next != NULL; j++) ///двигаемся пока не дойдем до конца или пока не дойдем до нужного столбца
        now = now->next;
    if((now->next == NULL && j < m) || (now->down == NULL && i < n))
    { ///проверка на то что нужный элемент находится в пределах размерности матрицы
        printf("Элемент за границами Матрицы\n");
        return;
    }
    sentenceOutput(now->sc); ///выводим значение Данного нужной ячейки матрицы
}

sentence* matrixTakeSentenceNM(matrix *first, int n, int m) ///передается указатель на первый элемент и индексы нужного элемента матрицы
{ ///находит значение взятого элемента и возвращает указатель на него
    matrix *now = first; ///локальный рабочий указатель
    sentence *tmp; ///буферная переменная
    int i, j; ///счетчики циклов

    if(now == NULL)
        return NULL;
    for(i = 0; i < n && now->down != NULL; i++) ///двигаемся пока не дойдем до конца или пока не дойдем до нужной строки
        now = now->down;
    for(j = 0; j < m && now->next != NULL; j++) ///двигаемся пока не дойдем до конца или пока не дойдем до нужного столбца
        now = now->next;
    if((now->next == NULL && j < m) || (now->down == NULL && i < n))
    { ///проверка на то что нужный элемент находится в пределах размерности матрицы
        printf("Элемент за границами Матрицы");
        return NULL;
    }
    tmp = now->sc;
    now->sc = NULL;

    return tmp;
}

void matrixShowRowN(matrix *first, int n) ///передается указатель на первый элемент и индекс строки
{ ///выводин в консоль строку с индексм n
    int i = 0; ///счетчик цикла поиска
    int j = 0; ///счетчик цикла вывода

    matrix *now = first; ///локальный рабочий указатель
    if(now == NULL) ///стандартная проверка
        return;
    for(i = 0; i < n && now->down != NULL; i++) ///двигаемся пока не дойдем до конца или пока не дойдем до нужной строки
        now = now->down;
    if(i < n && now->down == NULL)
    { ///проверка на то что нужный элемент находится в пределах размерности матрицы
        printf("Индекс за пределами матрицы\n");
        return;
    }
    for(j = 0; now->next != NULL; j++)
    {
        if(now->sc != NULL) ///выводим предложение, если оно не пустое
            sentenceOutput(now->sc, 26);
        else ///если оно пустое, сообщаем об этом
            printf("!!!_NULL_!!!              ");
        now = now->next;
    } ///цикл не обрабатывает последний элемент, поэтому он вынесен за пределы цикла
    if(now->sc != NULL)
    {
        sentenceOutput(now->sc, 25);
        printf("\n");
    }
    else
        printf("!!!_NULL_!!!             \n");
}

void matrixShowColM(matrix *first, int m) ///передается указатель на первый элемент и индекс столбца
{ ///выводит в консоль столбец с индексом m
    matrix *now = first; ///локальный рабочий указатель
    int j; ///счетчик цикла посика

    if(now == NULL) ///стандартная проверка
        return;
    for(j = 0; j < m && now->next != NULL; j++) ///двигаемся пока не дойдем до конца или пока не дойдем до нужного столбца
        now = now->next;
    if(j < m && now->next == NULL)
    { ///проверка на то что нужный элемент находится в пределах размерности матрицы
        printf("Индекс за пределами матрицы\n");
        return;
    }
    for(; now->down != NULL;)
    { ///выводим все элементы столбца матрицы, кроме последнего
        sentenceOutput(now->sc);
        now = now->down;
    } ///последний элемент выводим отдельно
    sentenceOutput(now->sc);
    printf("\n");
}

int matrixDeleteLastRow(matrix *first) ///передается указатель на первый элемент
{ ///удаляет последнюю строку матрицы
    matrix *now = first; ///локальный рабочий указатель

    if(now == NULL)
        return 1;
    if(now->down == NULL) ///если в матрице только одна строка, то проще полностью удалить матрицу (делается после вызова функции)
        return 2;
    for(; now->down->down != NULL; now = now->down); ///спускаемся до предпоследнего элемента
    for(; now->next != NULL;)
    { ///освобождаем память занимаемую последней строчкой и переопределяем новую последнюю строчку
        now->down->sc = sentenceDeleteALL(now->down->sc);
        free(now->down);
        now->down = NULL;
        now = now->next;
    } ///дорабатываем последний столбец матрицы
    free(now->down);
    now->down = NULL;

    return 0;
}

int matrixDeleteLastCol(matrix *first) ///передается указатель на первый элемент
{ ///удаляет последний столбец матрицы
    matrix *now = first; ///локальный рабочий указатель
    if(now == NULL) ///стандартная проверка
        return 1;
    if(now->next == NULL) ///если в матрице только один столбец, то проще полностью удалить матрицу (делается после вызова функции)
        return 2;
    for(; now->next->next != NULL; now = now->next); ///продвигаемся к предпоследнему столбцу
    for(; now->down != NULL;)
    { ///освобождаем память занимаемую последним столбцом и переопределям новый последний столбец
        now->next->sc = sentenceDeleteALL(now->next->sc);
        free(now->next);
        now->next = NULL;
        now = now->down;
    } ///дорабатываем элемент на последней строчке матрицы
    free(now->next);
    now->next = NULL;

    return 0;
}

void matrixOutput(matrix *first) ///передается указатель на первый элемент матрицы
{ ///выводит в консоль все содержание матрицы

    matrix *now; ///локальный рабочий указатель
    int i = 0, j = 0; ///счетчики индексов матрицы

    if(first == NULL) ///проверка матрицы на пустоту
        printf("Матрица пуста");
    else
    {
        for(; first->down != NULL; i++) ///проход по строкам матрицы о конца
        {
            now = first;
            for(j = 0; now->next != NULL; j++, now = now->next) ///вывод индексов столбцов
                printf("[%d][%d]                    ",i,j);
            printf("[%d][%d]                   \n",i,j);
            now = first;
            for(j = 0; now->next != NULL; j++) ///проход по столбцам матрицы до конца
            {
                if(now->sc != NULL) ///выводим предложение, если оно не пустое
                    sentenceOutput(now->sc, 26);
                else ///если оно пустое, сообщаем об этом
                    printf("!!!_NULL_!!!              ");
                now = now->next;
            } ///цикл не обрабатывает последний элемент, поэтому он вынесен за пределы цикла
            if(now->sc != NULL)
            {
                sentenceOutput(now->sc, 25);
                printf("\n");
            }
            else
                printf("!!!_NULL_!!!             \n");
            first = first->down;
        } ///цикл не обрабатывает последний элемент поэтому он вынесен за пределы цикла
        now = first;
        for(j = 0; now->next != NULL; j++, now = now->next)
            printf("[%d][%d]                    ",i,j);
        printf("[%d][%d]                   \n",i,j);
        now = first;
        for(j = 0; now->next != NULL; j++)
        {
            if(now->sc != NULL) ///выводим предложение, если оно не пустое
                sentenceOutput(now->sc, 26);
            else ///если оно пустое, сообщаем об этом
                printf("!!!_NULL_!!!              ");
            now = now->next;
        } ///цикл не обрабатывает последний элемент, поэтому он вынесен за пределы цикла
        if(now->sc != NULL)
        {
            sentenceOutput(now->sc, 25);
            printf("\n");
        }
        else
            printf("!!!_NULL_!!!             \n");
    }
}

matrix* matrixTakeRowN(matrix *first, int n) ///передается указатель на первый элемент и индекс строки
{ ///берет строку и выводит ее в консоль
    matrix *x; ///взятая строка
    matrix *tmp;
    matrix *now; ///локальный рабочий указатель
    int i; ///счетчик цикла

    if(first == NULL) ///стандартная проверка
        return NULL;
    now = first;
    if(n == 0) ///если мы берем нулевую строку, то у нас меняется указатель на первый элемент матрицы
    {
        first = first->down;
        x = now;
        for(; now->next != NULL;)
        {
            now->down=NULL;
            now=now->next;
        }
        now->down = NULL;
        printf("Взятая строка Матрицы\n");
        matrixOutput(x);
        return first; /// возвращаем новый указатель на первый элемент
    }
    for(i = 0; i < n && now->down != NULL; i++) ///бежим до нужной строки
    {
        tmp = now; ///отдельно сохраняем предыдущий элемент, чтобы потом поменять у него связи
        now = now->down;
    }
    if(i != n)
        return NULL; ///это значит, что мы не дошли до нужного элемента т.к. матрица меньше
    x = now; ///устанавливаем начало нашей берущейся строки
    for(; now->next != NULL;)
    { ///перенастраиваем всязи вырывая берущуюся строку в отдельную матрицу, которая стостоит из 1 строки
        tmp->down = now->down;
        now->down = NULL;
        now = now->next;
        tmp = tmp->next;
    } ///довырываем последний элемент т.к. цикл его не обрабатывает
    tmp->down = now->down;
    now->down = NULL;
    printf("Взятая строка Матрицы\n");
    matrixOutput(x); ///выводим взятую строку

    return first;
}

matrix* matrixTakeColM(matrix *first, int m) ///передается указатель на первый элемент матрицы и индекс столбца
{ ///берет столбец и выводит его в консоль
    matrix *x; ///взятый столбец
    matrix *tmp;
    matrix *now; ///локальный рабочий указатель
    int j; ///счетчик цикла

    if(first == NULL) ///стандартная проверка
        return NULL;
    now = first;
    if(m == 0) ///если мы берем нулевой столбец, то у нас меняется указатель на первый элемент матрицы
    {
        first = first->next;
        x = now;
        for(; now->down != NULL;)
        {
            now->next = NULL;
            now = now->down;
        }
        now->next = NULL;
        printf("Взятаый столбец Матрицы\n");
        matrixOutput(x);
        return first; ///возвращает новый указатель на первый элемент
    }
    for(j = 0; j < m && now->next != NULL; j++) ///бежим до нужного столбца
    {
        tmp = now; ///отдельно сохраняем предыдущий элемент, чтобы потом поменять у него связи
        now = now->next;
    }
    if(j != m)
        return NULL; ///проверка на то что мы не дошли до нужного элемента
    x = now; ///устанавливаем начало нашего берущегося столбца
    for(; now->down != NULL;)
    { ///перенастраиваем связи вырывая берущийся столбец в отдельную матрицу, которая состоит из 1 столбца
        tmp->next = now->next;
        now->next = NULL;
        now = now->down;
        tmp = tmp->down;
    } ///довырываем последний элемент т.к. матрица его не обрабатывает
    tmp->next = now->next;
    now->next = NULL; ///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    printf("Взятаый столбец Матрицы\n");
    matrixOutput(x); ///выводим взятую матрицу

    return first;
}

void matrixAddLastRow(matrix *first)///передается указатель на первый элемент
{ ///добавляет новую строку к уже имеющейся матрице
    matrix * tmp,
    *now = first; /// локальный рабочий указатель

    if(first == NULL) ///стандартная проверка
        return;
    for(; now->down != NULL;) ///спускаемся в самый низ, на последнюю строку
        now = now->down;
    tmp = matrixCreate(tmp); ///создаем новый элемент матрицы, внутри f() переходим на подуровень ниже
    now->down = tmp; ///присоединяем этот элемент к уже имеющейся матрице
    for(; now->next != NULL;) ///пока не дойдем до последнего столбца повторяем то же самое
    {
        tmp->next = matrixCreate(tmp->next);
        tmp = tmp->next;
        now = now->next;
        now->down = tmp;
    }
}

void matrixAddLastCol(matrix *first) ///передаем указатель на первый элемент
{ ///добавляем новый столбец в конец матрицы
    matrix *tmp,
    *now = first; ///локальный рабочий указатель

    if(first == NULL) ///стандартная проверка
        return;
    for(; now->next != NULL;) ///двигаемся к последнему столбцу
        now = now->next;
    tmp = matrixCreate(tmp); ///создаем новый элемент матрицы, внутри f() переходим на подуровень ниже
    now->next = tmp; ///присоединяем этот элемент к уже имеющейся матрице
    for(; now->down != NULL;) ///пока не дойдем до последней строки повторяем то же самое
    {
        tmp->down = matrixCreate(tmp->down);
        tmp = tmp->down;
        now = now->down;
        now->next = tmp;
    }
}

int matrixMenu(matrix *first)
{
    char tmp[10];
    int x = 0, i;

    system("cls");

    printf("\nДоступные операции над структурой данных Матрица\n\n");
    printf("1. Начать работу сматрицей\n");
    printf("2. Сделать матрицу пустой\n");
    printf("3. Проверка: матрица пуста?\n");
    printf("4. Определить число строк в матрице\n");
    printf("5. Определить число столбцов в матрице\n");
    printf("6. Показать значение элемента с индексами <N,M>\n");
    printf("7. Взять значение элемента с индексом <N,M>\n");
    printf("8. Изменить значение элемента с индексом <N,M>\n");
    printf("9. Показать строку с индексом <N>\n");
    printf("10. Показать столбец с индексом <M>\n");
    printf("11. Удалить строку матрицы (последнюю)\n");
    printf("12. Удалить столбец матрицы (последний)\n");
    printf("13. Взять строку матрицы с индексом <N>\n");
    printf("14. Взять столбец матрицы с индексом <M>\n");
    printf("15. Добавить строку\n");
    printf("16. Добавить столбец\n");
    printf("17. Распечатать матрицу\n");
    printf("18. Закончить работу с Динамической матрицей\n\n");
    matrixOutput(first);
    printf("\n\n> ");

    scanf("%s", tmp);
    for(i = 0; tmp[i] != '\0'; i++) ///посимвольное считывание команды и перевод её в целочисленный тип данных
        if(tmp[i] > 47 && tmp[i] < 58) ///если символ - число, то добавляем его в переменную, иначе отмечаем в переменной ошибку и прерываем цикл
            x = x*10+tmp[i]-48;
        else
        {
            x = 100;
            break;
        }
    for(; x < 1 || x > 18;) ///проверка на корректность введенных значений
    {
        printf("Введите корректное значение!!!\n");
        scanf("%s", tmp);
        for(i = 0, x = 0; tmp[i] != '\0'; i++) ///повторяем считывание и перевод, пока не будет введена корректная команда
            if(tmp[i] > 47 && tmp[i] < 58)
                x = x*10+tmp[i]-48;
            else
            {
                x = 100;
                break;
            }
    }

    return x;
}

void matrixStart()
{
    matrix *first = NULL; ///начальное значение первого элемента матрицы
    matrix *now = NULL; ///начальное значение рабочего указателя
    int menu = 0; ///выбранный пункт меню
    bool acces = 0; ///разрешен ли доступ к изменению матрицы
    int n, m; ///индексы выбираемых элементов матрицы
    sentence *tmp; ///предложение которое мы берем в 7 операции

    for(; menu != 18;)
    {
        menu = matrixMenu(first);
        switch(menu)
        {
            case 1:
                if(first != NULL) ///проверка матрицы на пустоту
                {
                    printf("Работа начатa: матрица не пустая\n");
                    now = first;
                }
                else
                {
                    printf("Работа начатa: матрица пустая\n");
                    now = first;
                }
                acces = 1;
                getchar();
                getchar();
            break;

            case 2:
                if(!acces) ///если доступ отсутствует, сообщается об этом
                {
                    printf("Начните работу для доступа к этой операции\n");
                    getchar();
                    getchar();
                }
                else
                {
                    first = matrixDeleteALL(first); ///после этой операции first = NULL
                    now = first;
                }
            break;

            case 3: ///проверка на пустоту
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(matrixIsEmpty(first)) ///проверка матрицы на пустоту
                        printf("Матрица пуста\n");
                    else
                        printf("В матрице что-то есть\n");
                getchar();
                getchar();
            break;

            case 4: ///определить число строк в матрице
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                        printf("В матрице %d строк", matrixRowCount(first));
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 5: ///определить число столбцов в матрице
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                        printf("В матрице %d столбцов", matrixColCount(first));
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 6: ///показать значение элемента с индесами n и m
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        printf("Введите значения N и M: ");
                        scanf("%d%d", &n, &m);
                        if(n < 0 || m < 0 || (n+1) > matrixRowCount(first) || (m+1) > matrixColCount(first)) ///проверка корректности введенных даннх
                            printf("Индекс за пределами матрицы\n");
                        else
                            matrixShowSentenceNM(first, n, m); ///выводим предложение на экран если все хорошо
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 7: ///взять значение элемента с индексом n и m
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        printf("Введите значения N и M: ");
                        scanf("%d%d", &n, &m);
                        if(n < 0 || m < 0 || (n+1) > matrixRowCount(first) || (m+1) > matrixColCount(first)) /// проверка корректности введенных значений
                            printf("Индекс за пределами матрицы\n");
                        else
                        {
                            tmp = matrixTakeSentenceNM(first, n, m); ///если все ок то получаем указатель на первый элемент Предложения
                            printf("\nВзятое значение:\n");
                            sentenceOutput(tmp); ///если взят NULL то внутри этой функции об этом сообщат
                        }
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 8: ///Изменить значение элемента с индексом n и m
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        printf("Введите значения N и M: ");
                        scanf("%d%d", &n, &m);
                        if(n < 0 || m < 0 || (n+1) > matrixRowCount(first) || (m+1) > matrixColCount(first)) ///проверка на то, что введённый индекс находится в пределах матрицы
                            printf("Индекс за пределами матрицы\n");
                        else
                        {
                            now = matrixGoTo(first, n, m); ///находим элемент с нужными индексами
                            if(now != NULL)
                                now->sc = sentenceStart(now->sc, now->sc); ///переходим в подуровень
                            else
                                now = first;
                        }
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 9: ///показать строчку с индексом n
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        printf("Введите значение N: ");
                        scanf("%d", &n);
                        if((n+1) > matrixRowCount(first) || n < 0) ///проверка на корректность введенного индекса
                            printf("Индекс за пределами матрицы\n");
                        else
                            matrixShowRowN(first, n);
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 10: ///Показать столбец с индексом m
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        printf("Введите значение M: ");
                        scanf("%d", &m);
                        if((m+1) > matrixColCount(first) || m < 0) ///проверка на корректность введенного индекса
                            printf("Индекс за пределами матрицы\n");
                        else
                            matrixShowColM(first, m);
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 11: ///удалить строку матрицы (последнюю)
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        int tmp = matrixDeleteLastRow(first); ///получаем код выполнения функции
                                ///если он != 0 значит в матрице оказалась одна строка
                        if(tmp) ///если в матрице оказалась одна строка, проще удалить всю матрицу
                            first = matrixDeleteALL(first);
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 12: ///удалить столбец матрицы (последний)
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        int tmp = matrixDeleteLastCol(first);///получаем код выполнения операции
                                ///если он != 0 значит в матрице осталась один столбец
                        if(tmp) ///в матрице оказалась один столбец, так что проще пересоздать матрицу
                            first = matrixDeleteALL(first);
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 13: ///Взять строку матрицы с индексом n
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        printf("Введите значение N: ");
                        scanf("%d", &n);
                        if(n < 0 || (n+1) > matrixRowCount(first)) ///проверка на корретность введенного индекса
                            printf("Индекс за пределами матрицы\n");
                        else
                            first = matrixTakeRowN(first, n);
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 14: ///взять столбец матрицы с индексом m
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                    {
                        printf("Введите значение M: ");
                        scanf("%d", &m);
                        if(m < 0 || (m+1) > matrixColCount(first)) ///проверка на корректность введенного индекса
                            printf("Индекс за пределами матрицы\n");
                        else
                            first = matrixTakeColM(first, m);
                    }
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 15: ///добавить строку
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                {
                    if(first != NULL) ///если в матрице что-то уже есть
                    {
                        matrixAddLastRow(first);
                        printf("Строка доавлена\n");
                    }
                    else ///если матрица пустая, то создаем матрицу
                    {
                        first = matrixCreate(first);
                        printf("Строка добавлена\n");
                    }
                }
                getchar();
                getchar();
            break;

            case 16: ///добавить столбец
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                {
                    if(first != NULL) ///если в матрице что-то есть
                    {
                        matrixAddLastCol(first);
                        printf("Столбец добавлен\n");
                    }
                    else ///если матрица пуста, то создаем матрицу
                    {
                        first = matrixCreate(first);
                        printf("Столбец добавлен\n");
                    }
                }
                getchar();
                getchar();
            break;

            case 17: ///Распечатать матрицу
                if(!acces) ///если доступ отсутствует, сообщается об этом
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка матрицы на пустоту
                        matrixOutput(first);
                    else
                        printf("Матрица пустая\n");
                getchar();
                getchar();
            break;

            case 18: ///Закончить работу с Динамической Матрицей
                first = matrixDeleteALL(first);
                exit(0);
        }
    }

}
