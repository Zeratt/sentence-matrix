struct sentence
{
    char *wd; ///указатель на данные
    sentence *next; ///указатель на следующий элемент списка
};


sentence *sentenceCreate(sentence *sc) ///функция отвечает за начальное заполнение структуры Предложение
{
    sc = (sentence*)malloc(sizeof(sentence)); ///выделяется память для хранения элемента
    if(sc == NULL) ///проверка на нехватку памяти
    {
        printf("Ошибка! Недостаточно памяти для работы программы.");
        exit(1);
    }
    sc->next = NULL; ///обозначается отсутствие следующего элемента
    sc->wd = (char *)malloc(sizeof(char)); ///выделяется память для слова
    if(sc->wd == NULL) ///проверка на нехватку памяти
    {
        printf("Ошибка! Недостаточно памяти для работы программы.");
        exit(1);
    }
    sc->wd[0] = '\0'; ///в слово добавляется \0 для обозначения пустоты слова для корректной работы printf()

    return sc;
}

sentence *sentenceDeleteALL(sentence *sc) ///функция удаляет все элементы предложения
{ /// переменна sc считается указателем на начало структуры
    sentence *tmp; /// эта переменная требуется для освобождения памяти находящейся перед указателем.
    ///поскольку указателя на предыдущий элемент нету, то требуется буферная переменная
    if(sc == NULL) ///стандартная проверка для исключения аварийной остановки программы посредством ОС
        return NULL;

    for(; sc->next != NULL;) ///цикл работает со всеми элементами структуры, кроме последнего
    {
        tmp = sc;
        sc=sc->next;
        free(tmp->wd);
        free(tmp);
    }
    free(sc); ///освобождается память последнего элемента
    sc = NULL;

    return sc;
}


bool sentenceIsEmpty(sentence *first) ///передается указатель на первый элемент
{ /// возвращает TRUE только если указатель на начало предложения = NULL
    if(first == NULL)
        return 1;
    else
        return 0;
}

sentence *sentenceNowToFirst(sentence *first, sentence *now) ///передается указатель на первый элемент и рабочий указатель
{ ///функция перемещает рабочий указатель в начало и возвращает новый рабочий указатель
    now = first;

    return now;
}

bool sentenceIsEnd(sentence *now) ///передается рабочий указатель
{ ///проверяет находится ли оказатель в конце предложения (указывает ли на последний элемент)
    if(now == NULL)
    { ///стандартная проверка для исключения возможности обращения по адресу не пренадлежащему программе
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return 1;
    }
    if(now->next == NULL)
        return 1; ///если следующего элемента не существет, то рабочий указатель находится в конце
    else
        return 0;
}

sentence *sentenceMoveToNext(sentence *now) ///передается рабочий указатель
{ ///передвигает рабочий указатель на следующий элемент
    if(now == NULL)
    { ///стандартная проверка для исключения возможности обращения к памяти не принадлежащей программе
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return NULL;
    }
    if(now->next != NULL) ///если следующий элемент не является последним, то рабочий указатель передвигается
        now = now->next;
    else ///в противном случае выдается ошибка
        printf("Ошибка. Это уже последний элемент\n");

    return now;
}

void sentenceShowNext(sentence *now) ///передается рабочий указатель
{ ///выводит в консоль слово, которое находится за указателем
    if(now == NULL)
    { ///стандартная проверка для исключения возможности обращения к памяти не принадлежащей программе
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return;
    }
    if(now->next != NULL) ///если следующий элемент не является последним, то в консоль выводится слово
        printf("%s\n", now->next->wd);
    else ///в противном случае выводится ошибка
        printf("Ошибка. Это уже последний элемент\n");
}

sentence *sentenceDeleteNext(sentence *now) ///передается рабочий указатель
{ ///удаляет слово, которое находится за указателем
    sentence *tmp, ///нужна для буферизации памяти, которая удаляется
    *tmp2; ///нужна для буферизации памяти, которая должна стать следующим элементам для элемента рабочего указателя
    if(now == NULL)
    { ///стандартная проверка для исключения возможности обращения к памяти не принадлежащей программе
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return NULL;
    }
    if(now->next != NULL) ///если рабочий указатель не в конце структуры, то
    {
        tmp = now->next; ///сохраняется указатель на следующий элемент
        tmp2 = now->next->next; ///сохраняется указатель на элемент после слудющего (даже если он = NULL это ни на что не влияет)
        free(tmp->wd); ///освобождается память, которая принадлежит данному предложения
        free(tmp); ///освобождается память находившаяся за рабочим указателем
        now->next = tmp2; ///следующим элементом элемента рабочего указателя становится следующий после удаленного
    }
    else /// если рабочий указатель в конце структуры, то выводится ошибка
        printf("Ошибка. Это уже последний элемент\n");

    return now;
}

char *sentenceTakeNext(sentence *now) ///передается рабочий указатель
{ ///берет элемент следующий за указателем и возвращает указатель на него
    sentence *tmp, ///нужна для буферизации памяти, которая будет
    *tmp2; ///нужна для буферизации памяти, которая должна стать следующим элементом для элемента рабочего указателя
    char *x; ///нужна для буферизации первого указателя на данное, которое нужно взять

    if(now == NULL)
    { ///стандартная проверка для исключения возможности обращения к памяти не принадлежащей программе
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return NULL;
    }
    if(now->next != NULL) ///функция выполняется только если рабочий указатель не является последним элементом
    {
        tmp = now->next; /// сохраняется указатель на следующий элемент
        tmp2 = now->next->next; ///сохраняется указатель на элемент после следующего (даже если он = NULL это ни на что не влияет)
        x = tmp->wd; ///сохраняется указатель на первый элемент данного
        free(tmp); ///освобождается память, но только память элемента структуры (не слова, которое принадлежит этому элементу)
        now->next = tmp2; ///следующим элементом элемента рабочего указателя становится следующий после удаленного
        return x; ///возвращается указатель на данное предложания, которое взяла функция
    }
    else ///если рабочий указатель указывает на последний лемент, то выводится ошибка
        printf("Ошибка. Это уже последний элемент\n");

    return NULL; ///если взять данное после элемента на который указывает рабочий указатель не получилось, то возвращается нулевой указатель
}

sentence *sentenceChangeNext(sentence *now) ///передается указатель на рабочий элемент
{ ///изменяет данное следующего элемента
    char tmp;
    int i;

    if(now == NULL)
    { ///по аналогии выше
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return NULL;
    }
    if(now->next != NULL) ///по аналогии выше
    {
        printf("Введите новое значение слова\n");
        free(now->next->wd); ///освобождаем старую память т.к. неизвестно, сколько будет занимать новое данное
        now->next->wd = (char* )malloc(sizeof(char)); ///выделяем память под новое данное
        if(now->next->wd == NULL) ///проверка на нехватку памяти
        {
            printf("Ошибка! Недостаточно памяти для работы программы.");
            exit(1);
        }
        now->next->wd[0] = '\0'; ///заносим значение поумолчанию
        scanf("%c", &tmp); ///начинаем считывать символы нового ланного
        i = 0;
        for(; tmp != ' ' && tmp != '\n'; i++) ///окончанием ввода является ввденный пробел или \n
        {
            now->next->wd[i] = tmp;
            now->next->wd = (char*)realloc(now->next->wd, sizeof(now->next->wd)+sizeof(char));
            ///увеличиваем размер для нового символа
            scanf("%c", &tmp); ///получаем новый символ
        } ///последний введенный символ не будет \0 поэтому его добавляем искуственно для корректной работы printf() в будущем
        now->next->wd[i] = '\0';
    }
    else
        printf("Ошибка. Это уже последний элемент\n");

    return now;
}

sentence *sentenceChangeNow(sentence *now)///передается рабочий указатель
{ ///изменяет данное на которое указывает рабочий указатель
    ///  !!! используется в исключительном случае
    int i = 0;

    if(now == NULL)
    {/// по аналогии выше
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return NULL;
    }
    printf("Введите новое значение слова\n");
    free(now->wd);
    now->wd = (char* )malloc(sizeof(char));
    if(now->wd == NULL) ///проверка на нехватку памяти
    {
        printf("Ошибка! Недостаточно памяти для работы программы.");
        exit(1);
    }
    now->wd[0] = '\0';
    char tmp;
    scanf("%c", &tmp);
    for(; tmp != ' ' && tmp != '\n'; i++)
    {
        now->wd[i] = tmp;
        now->wd = (char*)realloc(now->wd,sizeof(now->wd)+sizeof(char));
        scanf("%c",&tmp);
    }
    now->wd[i] = '\0';
    ///все происходит по полной аналогии с sentenceChangeNext()
    ///только меняется не следующий элемент, а нынешний

    return now;
}

sentence *sentenceAddNext(sentence *now) ///передается рабочий указатель
{ ///добавляет элемент после того на который указывает рабочий указатель
    sentence *tmp;
    char c;
    int i = 0;

    if(now == NULL)
    { ///по аналогии выше
        printf("Предложения не существует, выполнить операцию невозможно\n");
        return NULL;
    }
    tmp = now->next;
    now->next = (sentence*)malloc(sizeof(sentence));
    if(now->next == NULL) ///проверка на нехватку памяти
    {
        printf("Ошибка! Недостаточно памяти для работы программы.");
        exit(1);
    }
    now->next->next = tmp;
    now->next->wd = NULL;
    ///верхние 4 строчки - устанавливаются новые связи с новым элементом
    printf("Введите значение нового элемента\n");
    now->next->wd = (char* )malloc(sizeof(char));
    if(now->next->wd == NULL) ///проверка на нехватку памяти
    {
        printf("Ошибка! Недостаточно памяти для работы программы.");
        exit(1);
    }
    now->next->wd[0] = '\0';///нужно на случай проверки, что ничего не было введено
    scanf("%c", &c);
    for(; c != ' ' && c != '\n'; i++) ///цикл заполнения слова введёнными данными
    {
        now->next->wd[i] = c;
        now->next->wd = (char*)realloc(now->next->wd, sizeof(now->next->wd)+sizeof(char));
        scanf("%c", &c);
    }
    if(now->next->wd[0] == '\0') ///если ничего не было введено, то в данных остаётся NULL
    {
        printf("Вы ничего не ввели. (((\n");
        free(now->next->wd);
        now->next->wd = NULL;
        return now; ///чтобы не доходили до последних строчек и не обращались к не нашей памяти
    }
    now->next->wd[i] = '\0';

    return now;
}

void sentenceOutput(sentence *first, int len = 0, sentence *gnow = NULL) ///передается указатель на начало и, по желанию, общая длина требуемого вывода и указатель на рабочий элемент
{ ///выводит в консоль всю структуру. используется также и при выводе матрицы, поэтому передаваемый рабочий указатель gnow поумаолчанию = NULL
    sentence *now; ///рабочий указатель внутри функции
    int k, t;

    if(first == NULL)
    { ///по аналогии выше
        printf("Преджложение пустое\n");
        return;
    }
    now = first;
    for(k = 0; now->next != NULL; now = now->next) ///проход по всем элементам предложения и последовательный их вывод
    {
        if(gnow != NULL && gnow == now) ///если на данном элементе стоит рабочий указатель, то выводим стрелку
            printf("->");
        if(now->wd != NULL) ///если слово не пустое, то выводим слово, иначе выводим NULL
        {
            printf("%s ", now->wd);
            k += strlen(now->wd)+1;
        }
        else
        {
            printf("NULL ");
            k += 5;
        }
    }
    if(gnow != NULL && gnow == now) ///проверка последнего элемента на рабочий указатель и последующая его печать
            printf("->");
    printf("%s", now->wd);
    k += strlen(now->wd);
    if(len) ///если была передана длина, то допечатываем в конце требуемое количество пробелов
        for(t = 0; t < len-k; t++)
            printf(" ");
    else
        printf("\n");
    ///т.к. цикл не обрабатывает последний элемент, его приходится обрабатывать отдельно
}

int sentenceMenu(sentence *first, sentence *now) ///передаются указатели на первый и рабочий элементы
{ ///вывод меню на экран и считывание выбранного пункта
    char tmp[10];
    int x = 0, i;

    system("cls");

    printf("\nДоступные операции над структурой данных Предложение\n\n");
    printf("1. Начать работу с предложением\n");
    printf("2. Сделать предложение пустым\n");
    printf("3. Проверка: предложение поусто?\n");
    printf("4. Установить рабочий указатель в начало\n");
    printf("5. Проверка: указатель в конце предложения?\n");
    printf("6. Передвинуть рабочий указатель предложения вперед\n");
    printf("7. Показать значение элемента за указателем\n");
    printf("8. Удалить элемент предложения за указателем\n");
    printf("9. Взять элемент предложения за указателем\n");
    printf("10. Изменить значение элемента предложения за указателем\n");
    printf("11. Добавить элемент за указателем\n");
    printf("12. Распечатать структуру данных\n");
    printf("13. Закончить работу с предложением\n\n");
    sentenceOutput(first, 0, now);
    printf("\n\n> ");


    scanf("%s", tmp);
    for(i = 0; tmp[i] != '\0'; i++) ///посимвольное считывание команды и перевод её в целочисленный тип данных
        if(tmp[i] > 47 && tmp[i] < 58) ///если символ - число, то добавляем его в переменную, иначе отмечаем в переменной ошибку и прерываем цикл
            x = x*10+tmp[i]-48;
        else
        {
            x = 100;
            break;
        }
    for(; x < 1 || x > 18;) ///проверка на корректность введенных значений
    {
        printf("Введите корректное значение!!!\n");
        scanf("%s", tmp);
        for(i = 0, x = 0; tmp[i] != '\0'; i++) ///повторяем считывание и перевод, пока не будет введена корректная команда
            if(tmp[i] > 47 && tmp[i] < 58)
                x = x*10+tmp[i]-48;
            else
            {
                x = 100;
                break;
            }
    }

    return x;
}

sentence * sentenceStart(sentence *first = NULL, sentence *now = NULL) ///передается указатель на первый элемент и рабочий указатель. передача используется при вызове из структуры Матрица
{ ///отвечает за навигацию и вызов нужных функций при выборе определенного действия
    int menu = 0;
    bool acces = 0; ///доступ к операциям изменяющих Структуру
    char *tmp, t;

    for(; menu != 13;)
    {
        menu = sentenceMenu(first, now);
        switch(menu)
        {
            case 1: ///начало работы
                if(first != NULL) ///если указатель на первый элемент пуст, то работа начата
                    printf("Работа начата\n");
                else
                {
                    printf("Работа начата: предложение пустое\n");
                    now = first;
                }
                acces = 1;
                getchar();
            break;

            case 2: ///сделать список пустым
                if(!acces) ///проверка на наличие доступа
                {
                    printf("Начните работу для доступа к этой операции\n");
                    getchar();
                    getchar();
                }
                else
                { ///если доступ есть, освобождаем память и присваивем first = NULL и now = NULL
                    first = sentenceDeleteALL(first); ///после операции first = NULL
                    now = first; ///обязательно переопределить now.
                }
            break;

            case 3: ///Проверка: список пуст?
                if(!acces) ///проверка на наличие доступа
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(sentenceIsEmpty(first)) ///проверка на пустоту предложения
                        printf("Предложение пустое\n");
                    else
                        printf("В предложении что-то есть\n");
                getchar();
                getchar();
            break;

            case 4: ///Установить рабочий указатель в начало
                if(!acces) ///проверка на наличие доступа
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка предложения на пустоту
                    {
                        now = sentenceNowToFirst(first, now); /// проще было написать now = first, но задание требует использовать f()
                        printf("Рабочий указатель установлен в начало\n");
                    }
                    else
                        printf("Предложение пустое\n");
                getchar();
                getchar();
            break;

            case 5: ///Проверка: указатель в конце списка?
                if(!acces) ///проверка на наличие доступа
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка предложения на пустоту
                        if(sentenceIsEnd(now)) ///проверка указателя на нахождение в конце предложения
                            printf("Рабочий указатель в конце структуры\n");
                        else
                            printf("Рабочий указатель НЕ в конце структуры\n");
                    else
                        printf("Предложение пустое\n");
                getchar();
                getchar();
            break;

            case 6: ///Передвинуть рабочий указатель списка вперед
                if(!acces) ///проверка на наличие доступа
                {
                    printf("Начните работу для доступа к этой операции\n");
                    getchar();
                    getchar();
                }
                else
                    if(first != NULL) ///проверка предложения на пустоту
                        now = sentenceMoveToNext(now); ///возвращает новое значение рабочего указателя
                    else
                    {
                        printf("Предложение пустое\n");
                        getchar();
                        getchar();
                    }
            break;

            case 7: ///Показать значение элемента за указателем
                if(!acces) ///проверка на наличие доступа
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка предложения на пустоту
                        sentenceShowNext(now);
                    else
                        printf("Предложение пустое\n");
                getchar();
                getchar();
            break;

            case 8: ///Удалить элемент списка за указателем
                if(!acces) ///проверка на наличие доступа
                {
                    printf("Начните работу для доступа к этой операции\n");
                    getchar();
                    getchar();
                }
                else
                    if(first != NULL) ///проверка предложения на пустоту
                        sentenceDeleteNext(now);
                    else
                    {
                        printf("Предложение пустое\n");
                        getchar();
                        getchar();
                    }
            break;

            case 9: ///Взять элемент списка за указателем
                if(!acces) ///проверка на наличие доступа
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка предложения на пустоту
                    {
                        tmp = sentenceTakeNext(now); ///передаем указатель на взятое данное, а затем его выводим
                        if(tmp) ///проверка на то, взялся ли элемент
                            printf("Элемент взят. х = %s\n", tmp);
                        else
                            printf("Не удалось взять элемент\n");
                    }
                    else
                        printf("Предложение пустое\n");
                getchar();
                getchar();
            break;

            case 10: ///Изменить значение элемента списка за указателем
                if(!acces) ///проверка на наличие доступа
                {
                    printf("Начните работу для доступа к этой операции\n");
                    getchar();
                    getchar();
                }
                else
                    if(first != NULL) ///проверка предложения на пустоту
                    {
                        scanf("%c", &t); ///считываем случайно затесавшийся лишний символ, который портит всю малину
                        now = sentenceChangeNext(now);
                    }
                    else
                    {
                        printf("Добавте новый элемент, чтобы предложение не было пустым\n");
                        getchar();
                        getchar();
                    }
            break;

            case 11: ///добавить элемент списка за указателем
                if(!acces) ///проверка на наличие доступа
                {
                    printf("Начните работу для доступа к этой операции\n");
                    getchar();
                    getchar();
                }
                else
                    if(first != NULL) ///проверка предложения на пустоту
                    {
                        scanf("%c", &t);
                        now = sentenceAddNext(now);
                    }
                    else
                    { ///если список пустой, то нам нужно
                        scanf("%c", &t); ///прочитать лишний символ
                        first = sentenceCreate(first); ///создать новый первый элемент списка
                        now = first; ///поменять значение рабочего указателя
                        now = sentenceChangeNow(now); ///изменить значение элемента на которого указывает рабочий указатель т.к.
                    } ///sentenceCreate() только создает "оболочку" для данных, а не считывает их
            break;

            case 12: ///Распечатать структуру данных
                if(!acces) ///проверка на наличие доступа
                    printf("Начните работу для доступа к этой операции\n");
                else
                    if(first != NULL) ///проверка предложения на пустоту
                        if(sentenceIsEmpty(first)) ///проверка предложения на пустоту
                            printf("Предложение пустое\n");
                        else
                            sentenceOutput(first, 0, now);
                    else
                        printf("Предложение пустое\n");
                getchar();
                getchar();
            break;

            case 13:
                acces = 0;
                return first; ///возвращаем указатель на первый элемент списка, чтобы все изменения перешли на уровень выше в матрицу
        }

    }

}
